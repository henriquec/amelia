#!/usr/bin/env ruby

require 'listen'
require 'timeout'

class Webpack
  attr_accessor :pid, :listener_thread, :err_read, :err_write, :out_read, :out_write

  def command
    %w(npm run-script watch)
  end

  def env
    { 'NODE_ENV' => 'development' }
  end

  def options
    {
      out: out_write,
      err: err_write,
    }
  end

  def open_pipes
    self.err_read, self.err_write = IO.pipe
    self.out_read, self.out_write = IO.pipe
  end

  def close_pipes
    out_write.close unless out_write.closed?
    err_write.close unless err_write.closed?
    out_read.close unless out_read.closed?
    err_read.close unless err_read.closed?
  end

  def start
    open_pipes

    self.pid = Process.spawn(env, *command, options)

    out_write.close unless out_write.closed?
    err_write.close unless err_write.closed?
  end

  def listen
    self.listener_thread = Thread.new do
      print out_read.read(1) until out_read.eof?
    end
  end

  def stop_listening
    listener_thread.exit
  end

  def stop(wait_for = 5)
    Timeout.timeout(wait_for) do
      Process.kill('INT', pid)
      Process.wait(pid)
    end

  rescue Timeout::Error
    Process.kill('KILL', pid)
    Process.wait(pid)
  ensure
    stop_listening
    close_pipes
  end

  def restart(wait_for = 5)
    stop(wait_for) and start
  end
end

webpack = Webpack.new

webpack.start
webpack.listen

begin

  listener = Listen.to('app/assets/javascripts/apps') do |_, added, removed|
    if added.length > 0 or removed.length > 0
      puts "Restarting webpack ..."
      webpack.restart
      webpack.listen
    end
  end

  listener.start

  sleep

rescue SystemExit, Interrupt
  webpack.stop
  exit
end
